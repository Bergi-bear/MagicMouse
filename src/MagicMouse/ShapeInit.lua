---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by artem.
--- DateTime: 04.12.2021 8:02
---

Shapes = {}

--- sidesCount = {min, max}
--- sumOfAngles = {min, max}

function Interval(value, min, max)
    return value >= min and value <= max
end

function ShapeInit()
    square = Shape:new(function(sumOfAngles, angles, sides, data)
        for i = 1, #angles do
            if (angles[i] < 75) then
                return false
            end
        end
        if Interval(sumOfAngles, 260, 500) and Interval(#sides, 4, 5) and Distance(sides[1].start, sides[#sides].en) < 3 / 2 * 128 then
            --print("It's definitely a Square!",#data.Points)
            local x, y = GetCenterFigure(data)
            local r = GetRadiusCircle(data, x, y)
            CreateSquareCast(data, r, x, y, #data.Points)
            return true
        end
    end, function()

    end)

    triangle = Shape:new(function(sumOfAngles, angles, sides, data)
        for i = 1, #angles do
            if (angles[i] < 80) then
                return false
            end
        end
        if Interval(sumOfAngles, 300, 420) and Interval(#sides, 3, 3) and Distance(sides[1].start, sides[#sides].en) < 3 / 2 * 128 then
            local x, y = GetCenterFigure(data)
            CastLighting(data, 5, GetRadiusCircle(data, x, y), x, y)
            return true
        end
    end, function()
        --print("It's definitely a Triangle!")
    end)

    circle = Shape:new(function(sumOfAngles, angles, sides, data)
        if Interval(#sides, 1, 2) and Distance(sides[1].start, sides[#sides].en) < 3 / 2 * 128 then
            local x, y = GetCenterFigure(data)
            local r = GetRadiusCircle(data, x, y)

            if #data.Points > 7 then
                if ChkMediumRadius(data.Points, r, x, y) then
                    if #data.Points >= 35 then
                        --print("golem", #data.Points)
                        SummonInfernal(data, x, y, r, #data.Points)
                        return true
                    else
                        --print("Circle", #data.Points)
                        if IsUnitInRangeXY(data.UnitHero, x, y, r * 0.7) then
                            --print("лечение")
                            HealUnit(data.UnitHero, 50, nil, "Abilities\\Spells\\Human\\HolyBolt\\HolyBoltSpecialArt")
                        else
                            FlameStrike(data, x, y, r)
                        end
                        return true
                    end
                else

                    if DistanceBetweenXY(data.Points[1].x, data.Points[1].y, data.Points[#data.Points].x, data.Points[#data.Points].y) > 100 then
                        --print("wave")
                        CastWave(data,data.Points[1].x, data.Points[1].y, data.Points[#data.Points].x, data.Points[#data.Points].y)
                    else
                        print("кривой круг")
                    end
                    return true
                end
            else
                local angle = AngleBetweenXY(data.Points[1].x, data.Points[1].y, data.Points[#data.Points].x, data.Points[#data.Points].y) / bj_DEGTORAD
                EarthStrike(data, angle, x, y)
                --print("mini ", angle)
                return true
            end

        end

    end, function()
        -- return
    end)
    z = Shape:new(function(sumOfAngles, angles, sides, data)
        if Interval(sumOfAngles, 230, 320) and Interval(#sides, 3, 4) and Distance(sides[1].start, sides[#sides].en) > 3 * 128 then
            Blink2Point(data, GetCenterFigure(data))
            return true
        end

    end, function()
        --print("It's definitely a Z shape!")
        --return
    end)

    line = Shape:new(function(sumOfAngles, angles, sides, data)
        if Interval(#sides, 1, 1) and Distance(sides[1].start, sides[#sides].en) > 3 * 128 then
            local x1, y1, x2, y2 = data.Points[1].x, data.Points[1].y, data.Points[#data.Points].x, data.Points[#data.Points].y
            local angle = AngleBetweenXY(x1, y1, x2, y2) / bj_DEGTORAD

            --print("Line")
            local distCast = DistanceBetweenXY(x1, y1, GetUnitXY(data.UnitHero))

            if not data.lineActive then
                data.line1 = { x1, y1, x2, y2 }
                data.lineActive = true
                --print("линия 1")
                data.TimerLineDelay = CreateTimer()
                TimerStart(data.TimerLineDelay, 1, false, function()
                    --print("время вышло")
                    data.line1 = nil
                    data.lineActive = false
                end)
                if data.line2 then


                    ChkCross(data, x1, y1, x2, y2, data.line2[1], data.line2[2], data.line2[3], data.line2[4])

                else
                    if distCast <= 500  then
                        CreateAndForceBullet(data.UnitHero, angle, 40, "Abilities\\Weapons\\Mortar\\MortarMissile.mdl", nil, nil, 200)
                    else
                        print("Стена льда")
                    end
                end
            else
                data.lineActive = false
                data.line2 = { x1, y1, x2, y2 }
                --print("линия 2")
                if data.line1 then


                    ChkCross(data, x1, y1, x2, y2, data.line1[1], data.line1[2], data.line1[3], data.line1[4])
                    --end
                else
                    if distCast <= 500  then
                        CreateAndForceBullet(data.UnitHero, angle, 40, "Abilities\\Weapons\\Mortar\\MortarMissile.mdl", nil, nil, 200)
                    else

                    end
                end
            end

            return true
        end
    end, function()
        --return
    end)

    curve = Shape:new(function(sumOfAngles, angles, sides, data)
        if Interval(#sides, 1, 3) and Distance(sides[1].start, sides[#sides].en) > 3 * 128 then
            --local angle = AngleBetweenXY(data.Points[1].x, data.Points[1].y, data.Points[#data.Points].x, data.Points[#data.Points].y) / bj_DEGTORAD
            --CreateAndForceBullet(data.UnitHero, angle, 40, "Abilities\\Weapons\\Mortar\\MortarMissile.mdl", nil, nil, 150)
            local dist = DistanceBetweenXY(data.Points[1].x, data.Points[1].y, GetUnitXY(data.UnitHero))
            if dist <= 150 then
                MoveToCurve(data, data.Points)
                return true
            else

            end


        end

    end, function()
        --return
    end)

    m = Shape:new(function(sumOfAngles, angles, sides, data)
        return Interval(sumOfAngles, 400, 650) and Interval(#sides, 4, 5) and Distance(sides[1].start, sides[#sides].en) > 3 * 128
    end, function()
        print("It's definitely a M shape!")
    end)

    sandClock = Shape:new(function(sumOfAngles, angles, sides, data)
        for i = 1, #angles do
            if (angles[i] < 90) then
                return false
            end
        end
        return Interval(sumOfAngles, 500, 600) and Interval(#sides, 4, 5) and Distance(sides[1].start, sides[#sides].en) < 2 * 128
    end, function()
        print("It's definitely a Sand Clock!")
    end)

    Shapes = { square, triangle, circle, line, z, m, sandClock, curve }
end